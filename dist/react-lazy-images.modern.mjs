import e from"react";import t from"react-intersection-observer";import{unionize as r,ofType as a}from"unionize";function o(e,t){if(null==e)return{};var r,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)t.indexOf(r=s[a])>=0||(o[r]=e[r]);return o}const s=["children","loadEagerly","observerProps","experimentalDecode","debounceDurationMs","debugActions"];var n;!function(e){e.NotAsked="NotAsked",e.Loading="Loading",e.LoadSuccess="LoadSuccess",e.LoadError="LoadError"}(n||(n={}));const i=r({NotAsked:{},Buffering:{},Loading:{},LoadSuccess:{},LoadError:a()}),c=r({ViewChanged:a(),BufferingEnded:{},LoadSuccess:{},LoadError:a()}),d=(e,t)=>r=>{const a=p(m(e,t));a.promise.then(e=>r.update(c.LoadSuccess({}))).catch(e=>{e.isCanceled||r.update(c.LoadError({msg:"Failed to load"}))}),r.promiseCache.loading=a},u=e=>{e.promiseCache.buffering.cancel()};class h extends e.Component{constructor(e){super(e),this.promiseCache={},this.initialState=i.NotAsked(),this.state=this.initialState,this.update=this.update.bind(this)}static reducer(e,t,r){return c.match(e,{ViewChanged:({inView:e})=>!0===e?r.src?i.match(t,{NotAsked:()=>{return r.debounceDurationMs?{nextState:i.Buffering(),cmd:(e=r.debounceDurationMs,t=>{const r=p(g(e));r.promise.then(()=>t.update(c.BufferingEnded())).catch(e=>{}),t.promiseCache.buffering=r})}:{nextState:i.Loading(),cmd:d(r,r.experimentalDecode)};var e},default:()=>({nextState:t})}):{nextState:i.LoadSuccess()}:i.match(t,{Buffering:()=>({nextState:i.NotAsked(),cmd:u}),default:()=>({nextState:t})}),BufferingEnded:()=>({nextState:i.Loading(),cmd:d(r,r.experimentalDecode)}),LoadSuccess:()=>({nextState:i.LoadSuccess()}),LoadError:e=>({nextState:i.LoadError(e)})})}update(e){const{nextState:t,cmd:r}=h.reducer(e,this.state,this.props);this.props.debugActions&&("production"===process.env.NODE_ENV&&console.warn('You are running LazyImage with debugActions="true" in production. This might have performance implications.'),console.log({action:e,prevState:this.state,nextState:t})),this.setState(t,()=>r&&r(this))}componentWillUnmount(){this.promiseCache.loading&&this.promiseCache.loading.cancel(),this.promiseCache.buffering&&this.promiseCache.buffering.cancel(),this.promiseCache={}}render(){const r=this.props,{children:a,loadEagerly:d,observerProps:u}=r,h=o(r,s);return d?a({imageState:i.LoadSuccess().tag,imageProps:h}):e.createElement(t,Object.assign({rootMargin:"50px 0px",threshold:.01},u,{onChange:e=>this.update(c.ViewChanged({inView:e}))}),({ref:e})=>a({imageState:"Buffering"===this.state.tag?n.Loading:this.state.tag,imageProps:h,ref:e}))}}h.displayName="LazyImageFull";const m=({src:e,srcSet:t,alt:r,sizes:a},o=!1)=>new Promise((s,n)=>{const i=new Image;if(t&&(i.srcset=t),r&&(i.alt=r),a&&(i.sizes=a),i.src=e,o&&"decode"in i)return i.decode().then(()=>s(i)).catch(e=>n(e));i.onload=s,i.onerror=n}),g=e=>new Promise(t=>setTimeout(t,e)),p=e=>{let t=!1;return{promise:new Promise((r,a)=>{e.then(e=>t?a({isCanceled:!0}):r(e)),e.catch(e=>a(t?{isCanceled:!0}:e))}),cancel(){t=!0}}},l=["actual","placeholder","loading","error"],f=t=>{let{actual:r,placeholder:a,loading:s,error:i}=t,c=o(t,l);return e.createElement(h,Object.assign({},c),({imageState:e,imageProps:t,ref:o})=>{switch(e){case n.NotAsked:return!!a&&a({imageProps:t,ref:o});case n.Loading:return s?s():!!a&&a({imageProps:t,ref:o});case n.LoadSuccess:return r({imageProps:t});case n.LoadError:return i?i():r({imageProps:t})}})};f.displayName="LazyImage";export{n as ImageState,f as LazyImage,h as LazyImageFull};
//# sourceMappingURL=react-lazy-images.modern.mjs.map
