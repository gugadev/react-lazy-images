{"version":3,"file":"react-lazy-images.modern.mjs","sources":["../src/LazyImageFull.tsx","../src/LazyImage.tsx"],"sourcesContent":["import React from \"react\";\nimport Observer from \"react-intersection-observer\";\nimport { unionize, ofType, UnionOf } from \"unionize\";\n\n/**\n * Valid props for LazyImage components\n */\nexport type CommonLazyImageProps = ImageProps & {\n  // NOTE: if you add props here, remember to destructure them out of being\n  // passed to the children, in the render() callback.\n\n  /** Whether to skip checking for viewport and always show the 'actual' component\n   * @see https://github.com/fpapado/react-lazy-images/#eager-loading--server-side-rendering-ssr\n   */\n  loadEagerly?: boolean;\n\n  /** Subset of props for the IntersectionObserver\n   * @see https://github.com/thebuilder/react-intersection-observer#props\n   */\n  observerProps?: ObserverProps;\n\n  /** Use the Image Decode API;\n   * The call to a new HTML <img> elementâ€™s decode() function returns a promise, which,\n   * when fulfilled, ensures that the image can be appended to the DOM without causing\n   * a decoding delay on the next frame.\n   *  @see: https://www.chromestatus.com/feature/5637156160667648\n   */\n  experimentalDecode?: boolean;\n\n  /** Whether to log out internal state transitions for the component */\n  debugActions?: boolean;\n\n  /** Delay a certain duration before starting to load, in ms.\n   * This can help avoid loading images while the user scrolls quickly past them.\n   * TODO: naming things.\n   */\n  debounceDurationMs?: number;\n};\n\n/** Valid props for LazyImageFull */\nexport interface LazyImageFullProps extends CommonLazyImageProps {\n  /** Children should be either a function or a node */\n  children: (args: RenderCallbackArgs) => React.ReactNode;\n}\n\n/** Values that the render props take */\nexport interface RenderCallbackArgs {\n  imageState: ImageState;\n  imageProps: ImageProps;\n  /** When not loading eagerly, a ref to bind to the DOM element. This is needed for the intersection calculation to work. */\n  ref?: React.RefObject<any>;\n}\n\nexport interface ImageProps {\n  /** The source of the image to load */\n  src: string;\n\n  /** The source set of the image to load */\n  srcSet?: string;\n\n  /** The alt text description of the image you are loading */\n  alt?: string;\n\n  /** Sizes descriptor */\n  sizes?: string;\n}\n\n/** Subset of react-intersection-observer's props */\nexport interface ObserverProps {\n  /**\n   * Margin around the root that expands the area for intersection.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/rootMargin\n   * @default \"50px 0px\"\n   * @example Declaration same as CSS margin:\n   *  `\"10px 20px 30px 40px\"` (top, right, bottom, left).\n   */\n  rootMargin?: string;\n\n  /** Number between 0 and 1 indicating the the percentage that should be\n   * visible before triggering.\n   * @default `0.01`\n   */\n  threshold?: number;\n}\n\n/** States that the image loading can be in.\n * Used together with LazyImageFull render props.\n * External representation of the internal state.\n * */\nexport enum ImageState {\n  NotAsked = \"NotAsked\",\n  Loading = \"Loading\",\n  LoadSuccess = \"LoadSuccess\",\n  LoadError = \"LoadError\"\n}\n\n/** The component's state */\nconst LazyImageFullState = unionize({\n  NotAsked: {},\n  Buffering: {},\n  // Could try to make it Promise<HTMLImageElement>,\n  // but we don't use the element anyway, and we cache promises\n  Loading: {},\n  LoadSuccess: {},\n  LoadError: ofType<{ msg: string }>()\n});\n\ntype LazyImageFullState = UnionOf<typeof LazyImageFullState>;\n\n/** Actions that change the component's state.\n * These are not unlike Actions in Redux or, the ones I'm inspired by,\n * Msg in Elm.\n */\nconst Action = unionize({\n  ViewChanged: ofType<{ inView: boolean }>(),\n  BufferingEnded: {},\n  // MAYBE: Load: {},\n  LoadSuccess: {},\n  LoadError: ofType<{ msg: string }>()\n});\n\ntype Action = UnionOf<typeof Action>;\n\n/** Commands (Cmd) describe side-effects as functions that take the instance */\n// FUTURE: These should be tied to giving back a Msg / asynchronoulsy giving a Msg with conditions\ntype Cmd = (instance: LazyImageFull) => void;\n\n/** The output from a reducer is the next state and maybe a command */\ntype ReducerResult = {\n  nextState: LazyImageFullState;\n  cmd?: Cmd;\n};\n\n///// Commands, things that perform side-effects /////\n/** Get a command that sets a buffering Promise */\nconst getBufferingCmd = (durationMs: number): Cmd => instance => {\n  // Make cancelable buffering Promise\n  const bufferingPromise = makeCancelable(delayedPromise(durationMs));\n\n  // Kick off promise chain\n  bufferingPromise.promise\n    .then(() => instance.update(Action.BufferingEnded()))\n    .catch(\n      _reason => {}\n      //console.log({ isCanceled: _reason.isCanceled })\n    );\n\n  // Side-effect; set the promise in the cache\n  instance.promiseCache.buffering = bufferingPromise;\n};\n\n/** Get a command that sets an image loading Promise */\nconst getLoadingCmd = (\n  imageProps: ImageProps,\n  experimentalDecode?: boolean\n): Cmd => instance => {\n  // Make cancelable loading Promise\n  const loadingPromise = makeCancelable(\n    loadImage(imageProps, experimentalDecode)\n  );\n\n  // Kick off request for Image and attach listeners for response\n  loadingPromise.promise\n    .then(_res => instance.update(Action.LoadSuccess({})))\n    .catch(e => {\n      // If the Loading Promise was canceled, it means we have stopped\n      // loading due to unmount, rather than an error.\n      if (!e.isCanceled) {\n        // TODO: think more about the error here\n        instance.update(Action.LoadError({ msg: \"Failed to load\" }));\n      }\n    });\n\n  // Side-effect; set the promise in the cache\n  instance.promiseCache.loading = loadingPromise;\n};\n\n/** Command that cancels the buffering Promise */\nconst cancelBufferingCmd: Cmd = instance => {\n  // Side-effect; cancel the promise in the cache\n  // We know this exists if we are in a Buffering state\n  instance.promiseCache.buffering.cancel();\n};\n\n/**\n * Component that preloads the image once it is in the viewport,\n * and then swaps it in. Takes a render prop that allows to specify\n * what is rendered based on the loading state.\n */\nexport class LazyImageFull extends React.Component<\n  LazyImageFullProps,\n  LazyImageFullState\n> {\n  static displayName = \"LazyImageFull\";\n\n  /** A central place to store promises.\n   * A bit silly, but passing promsises directly in the state\n   * was giving me weird timing issues. This way we can keep\n   * the promises in check, and pick them up from the respective methods.\n   * FUTURE: Could pass the relevant key in Buffering and Loading, so\n   * that at least we know where they are from a single source.\n   */\n  promiseCache: {\n    [key: string]: CancelablePromise;\n  } = {};\n\n  initialState = LazyImageFullState.NotAsked();\n\n  /** Emit the next state based on actions.\n   *  This is the core of the component!\n   */\n  static reducer(\n    action: Action,\n    prevState: LazyImageFullState,\n    props: LazyImageFullProps\n  ): ReducerResult {\n    return Action.match(action, {\n      ViewChanged: ({ inView }) => {\n        if (inView === true) {\n          // If src is not specified, then there is nothing to preload; skip to Loaded state\n          if (!props.src) {\n            return { nextState: LazyImageFullState.LoadSuccess() }; // Error wtf\n          } else {\n            // If in view, only load something if NotAsked, otherwise leave untouched\n            return LazyImageFullState.match(prevState, {\n              NotAsked: () => {\n                // If debounce is specified, then start buffering\n                if (!!props.debounceDurationMs) {\n                  return {\n                    nextState: LazyImageFullState.Buffering(),\n                    cmd: getBufferingCmd(props.debounceDurationMs)\n                  };\n                } else {\n                  // If no debounce is specified, then start loading immediately\n                  return {\n                    nextState: LazyImageFullState.Loading(),\n                    cmd: getLoadingCmd(props, props.experimentalDecode)\n                  };\n                }\n              },\n              // Do nothing in other states\n              default: () => ({ nextState: prevState })\n            });\n          }\n        } else {\n          // If out of view, cancel if Buffering, otherwise leave untouched\n          return LazyImageFullState.match(prevState, {\n            Buffering: () => ({\n              nextState: LazyImageFullState.NotAsked(),\n              cmd: cancelBufferingCmd\n            }),\n            // Do nothing in other states\n            default: () => ({ nextState: prevState })\n          });\n        }\n      },\n      // Buffering has ended/succeeded, kick off request for image\n      BufferingEnded: () => ({\n        nextState: LazyImageFullState.Loading(),\n        cmd: getLoadingCmd(props, props.experimentalDecode)\n      }),\n      // Loading the image succeeded, simple\n      LoadSuccess: () => ({ nextState: LazyImageFullState.LoadSuccess() }),\n      // Loading the image failed, simple\n      LoadError: e => ({ nextState: LazyImageFullState.LoadError(e) })\n    });\n  }\n\n  constructor(props: LazyImageFullProps) {\n    super(props);\n    this.state = this.initialState;\n\n    // Bind methods\n    this.update = this.update.bind(this);\n  }\n\n  update(action: Action) {\n    // Get the next state and any effects\n    const { nextState, cmd } = LazyImageFull.reducer(\n      action,\n      this.state,\n      this.props\n    );\n\n    // Debugging\n    if (this.props.debugActions) {\n      if (process.env.NODE_ENV === \"production\") {\n        console.warn(\n          'You are running LazyImage with debugActions=\"true\" in production. This might have performance implications.'\n        );\n      }\n      console.log({ action, prevState: this.state, nextState });\n    }\n\n    // Actually set the state, and kick off any effects after that\n    this.setState(nextState, () => cmd && cmd(this));\n  }\n\n  componentWillUnmount() {\n    // Clear the Promise Cache\n    if (this.promiseCache.loading) {\n      // NOTE: This does not cancel the request, only the callback.\n      // We weould need fetch() and an AbortHandler for that.\n      this.promiseCache.loading.cancel();\n    }\n    if (this.promiseCache.buffering) {\n      this.promiseCache.buffering.cancel();\n    }\n    this.promiseCache = {};\n  }\n\n  // Render function\n  render() {\n    // This destructuring is silly\n    const {\n      children,\n      loadEagerly,\n      observerProps,\n      experimentalDecode,\n      debounceDurationMs,\n      debugActions,\n      ...imageProps\n    } = this.props;\n\n    if (loadEagerly) {\n      // If eager, skip the observer and view changing stuff; resolve the imageState as loaded.\n      return children({\n        // We know that the state tags and the enum match up\n        imageState: LazyImageFullState.LoadSuccess().tag as ImageState,\n        imageProps\n      });\n    } else {\n      return (\n        <Observer\n          rootMargin=\"50px 0px\"\n          // TODO: reconsider threshold\n          threshold={0.01}\n          {...observerProps}\n          onChange={inView => this.update(Action.ViewChanged({ inView }))}\n        >\n          {({ ref }) =>\n            children({\n              // We know that the state tags and the enum match up, apart\n              // from Buffering not being exposed\n              imageState:\n                this.state.tag === \"Buffering\"\n                  ? ImageState.Loading\n                  : (this.state.tag as ImageState),\n              imageProps,\n              ref\n            })\n          }\n        </Observer>\n      );\n    }\n  }\n}\n\n///// Utilities /////\n\n/** Promise constructor for loading an image */\nconst loadImage = (\n  { src, srcSet, alt, sizes }: ImageProps,\n  experimentalDecode = false\n) =>\n  new Promise((resolve, reject) => {\n    const image = new Image();\n    if (srcSet) {\n      image.srcset = srcSet;\n    }\n    if (alt) {\n      image.alt = alt;\n    }\n    if (sizes) {\n      image.sizes = sizes;\n    }\n    image.src = src;\n\n    /** @see: https://www.chromestatus.com/feature/5637156160667648 */\n    if (experimentalDecode && \"decode\" in image) {\n      return (\n        image\n          // NOTE: .decode() is not in the TS defs yet\n          // TODO: consider writing the .decode() definition and sending a PR\n          //@ts-ignore\n          .decode()\n          .then(() => resolve(image))\n          .catch((err: any) => reject(err))\n      );\n    }\n\n    image.onload = resolve;\n    image.onerror = reject;\n  });\n\n/** Promise that resolves after a specified number of ms */\nconst delayedPromise = (ms: number) =>\n  new Promise(resolve => setTimeout(resolve, ms));\n\ninterface CancelablePromise {\n  promise: Promise<{}>;\n  cancel: () => void;\n}\n\n/** Make a Promise \"cancelable\".\n *\n * Rejects with {isCanceled: true} if canceled.\n *\n * The way this works is by wrapping it with internal hasCanceled_ state\n * and checking it before resolving.\n */\nconst makeCancelable = (promise: Promise<any>): CancelablePromise => {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise<{}>((resolve, reject) => {\n    promise.then((val: any) =>\n      hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)\n    );\n    promise.catch((error: any) =>\n      hasCanceled_ ? reject({ isCanceled: true }) : reject(error)\n    );\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    }\n  };\n};\n","import React from \"react\";\nimport {\n  LazyImageFull,\n  CommonLazyImageProps,\n  ImageState,\n  ImageProps\n} from \"./LazyImageFull\";\n\n/**\n * Valid props for LazyImage\n */\nexport interface LazyImageRenderPropArgs {\n  imageProps: ImageProps;\n}\n\nexport interface RefArg {\n  /** When not loading eagerly, a ref to bind to the DOM element. This is needed for the intersection calculation to work. */\n  ref?: React.RefObject<any>;\n}\n\nexport interface LazyImageProps extends CommonLazyImageProps {\n  /** Component to display once image has loaded */\n  actual: (args: LazyImageRenderPropArgs) => React.ReactElement<{}>;\n\n  /** Component to display while image has not been requested\n   * @default: undefined\n   */\n  placeholder: (\n    args: LazyImageRenderPropArgs & RefArg\n  ) => React.ReactElement<{}>;\n\n  /** Component to display while the image is loading\n   * @default placeholder, if defined\n   */\n  loading?: () => React.ReactElement<{}>;\n\n  /** Component to display if the image fails to load\n   * @default actual (broken image)\n   */\n  error?: () => React.ReactElement<{}>;\n}\n\n/**\n * Component that preloads the image once it is in the viewport,\n * and then swaps it in. Has predefined rendering logic, but the\n * specifics are up to the caller.\n */\nexport const LazyImage: React.StatelessComponent<LazyImageProps> = ({\n  actual,\n  placeholder,\n  loading,\n  error,\n  ...rest\n}) => (\n  <LazyImageFull {...rest}>\n    {({ imageState, imageProps, ref }) => {\n      // Call the appropriate render callback based on the state\n      // and the props specified, passing on relevant props.\n      switch (imageState) {\n        case ImageState.NotAsked:\n          return !!placeholder && placeholder({ imageProps, ref });\n\n        case ImageState.Loading:\n          // Only render loading if specified, otherwise placeholder\n          return !!loading\n            ? loading()\n            : !!placeholder && placeholder({ imageProps, ref });\n\n        case ImageState.LoadSuccess:\n          return actual({ imageProps });\n\n        case ImageState.LoadError:\n          // Only render error if specified, otherwise actual (broken image)\n          return !!error ? error() : actual({ imageProps });\n      }\n    }}\n  </LazyImageFull>\n);\n\nLazyImage.displayName = \"LazyImage\";\n"],"names":["_excluded","ImageState","LazyImageFullState","unionize","NotAsked","Buffering","Loading","LoadSuccess","LoadError","ofType","Action","ViewChanged","BufferingEnded","getLoadingCmd","imageProps","experimentalDecode","instance","loadingPromise","makeCancelable","loadImage","promise","then","_res","update","catch","e","isCanceled","msg","promiseCache","loading","cancelBufferingCmd","buffering","cancel","LazyImageFull","React","Component","constructor","props","super","this","initialState","state","bind","static","action","prevState","match","inView","src","debounceDurationMs","nextState","cmd","durationMs","bufferingPromise","delayedPromise","_reason","default","reducer","debugActions","process","env","NODE_ENV","console","warn","log","setState","componentWillUnmount","render","_this$props","children","loadEagerly","observerProps","_objectWithoutPropertiesLoose","imageState","tag","createElement","Observer","Object","assign","rootMargin","threshold","onChange","ref","displayName","srcSet","alt","sizes","Promise","resolve","reject","image","Image","srcset","decode","err","onload","onerror","ms","setTimeout","hasCanceled_","val","error","_ref","actual","placeholder","rest","LazyImage"],"mappings":"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"}