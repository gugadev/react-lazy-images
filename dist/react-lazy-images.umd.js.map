{"version":3,"file":"react-lazy-images.umd.js","sources":["../src/LazyImageFull.tsx","../src/LazyImage.tsx"],"sourcesContent":["import React from \"react\";\nimport Observer from \"react-intersection-observer\";\nimport { unionize, ofType, UnionOf } from \"unionize\";\n\n/**\n * Valid props for LazyImage components\n */\nexport type CommonLazyImageProps = ImageProps & {\n  // NOTE: if you add props here, remember to destructure them out of being\n  // passed to the children, in the render() callback.\n\n  /** Whether to skip checking for viewport and always show the 'actual' component\n   * @see https://github.com/fpapado/react-lazy-images/#eager-loading--server-side-rendering-ssr\n   */\n  loadEagerly?: boolean;\n\n  /** Subset of props for the IntersectionObserver\n   * @see https://github.com/thebuilder/react-intersection-observer#props\n   */\n  observerProps?: ObserverProps;\n\n  /** Use the Image Decode API;\n   * The call to a new HTML <img> elementâ€™s decode() function returns a promise, which,\n   * when fulfilled, ensures that the image can be appended to the DOM without causing\n   * a decoding delay on the next frame.\n   *  @see: https://www.chromestatus.com/feature/5637156160667648\n   */\n  experimentalDecode?: boolean;\n\n  /** Whether to log out internal state transitions for the component */\n  debugActions?: boolean;\n\n  /** Delay a certain duration before starting to load, in ms.\n   * This can help avoid loading images while the user scrolls quickly past them.\n   * TODO: naming things.\n   */\n  debounceDurationMs?: number;\n};\n\n/** Valid props for LazyImageFull */\nexport interface LazyImageFullProps extends CommonLazyImageProps {\n  /** Children should be either a function or a node */\n  children: (args: RenderCallbackArgs) => React.ReactNode;\n}\n\n/** Values that the render props take */\nexport interface RenderCallbackArgs {\n  imageState: ImageState;\n  imageProps: ImageProps;\n  /** When not loading eagerly, a ref to bind to the DOM element. This is needed for the intersection calculation to work. */\n  ref?: React.RefObject<any>;\n}\n\nexport interface ImageProps {\n  /** The source of the image to load */\n  src: string;\n\n  /** The source set of the image to load */\n  srcSet?: string;\n\n  /** The alt text description of the image you are loading */\n  alt?: string;\n\n  /** Sizes descriptor */\n  sizes?: string;\n}\n\n/** Subset of react-intersection-observer's props */\nexport interface ObserverProps {\n  /**\n   * Margin around the root that expands the area for intersection.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/rootMargin\n   * @default \"50px 0px\"\n   * @example Declaration same as CSS margin:\n   *  `\"10px 20px 30px 40px\"` (top, right, bottom, left).\n   */\n  rootMargin?: string;\n\n  /** Number between 0 and 1 indicating the the percentage that should be\n   * visible before triggering.\n   * @default `0.01`\n   */\n  threshold?: number;\n}\n\n/** States that the image loading can be in.\n * Used together with LazyImageFull render props.\n * External representation of the internal state.\n * */\nexport enum ImageState {\n  NotAsked = \"NotAsked\",\n  Loading = \"Loading\",\n  LoadSuccess = \"LoadSuccess\",\n  LoadError = \"LoadError\"\n}\n\n/** The component's state */\nconst LazyImageFullState = unionize({\n  NotAsked: {},\n  Buffering: {},\n  // Could try to make it Promise<HTMLImageElement>,\n  // but we don't use the element anyway, and we cache promises\n  Loading: {},\n  LoadSuccess: {},\n  LoadError: ofType<{ msg: string }>()\n});\n\ntype LazyImageFullState = UnionOf<typeof LazyImageFullState>;\n\n/** Actions that change the component's state.\n * These are not unlike Actions in Redux or, the ones I'm inspired by,\n * Msg in Elm.\n */\nconst Action = unionize({\n  ViewChanged: ofType<{ inView: boolean }>(),\n  BufferingEnded: {},\n  // MAYBE: Load: {},\n  LoadSuccess: {},\n  LoadError: ofType<{ msg: string }>()\n});\n\ntype Action = UnionOf<typeof Action>;\n\n/** Commands (Cmd) describe side-effects as functions that take the instance */\n// FUTURE: These should be tied to giving back a Msg / asynchronoulsy giving a Msg with conditions\ntype Cmd = (instance: LazyImageFull) => void;\n\n/** The output from a reducer is the next state and maybe a command */\ntype ReducerResult = {\n  nextState: LazyImageFullState;\n  cmd?: Cmd;\n};\n\n///// Commands, things that perform side-effects /////\n/** Get a command that sets a buffering Promise */\nconst getBufferingCmd = (durationMs: number): Cmd => instance => {\n  // Make cancelable buffering Promise\n  const bufferingPromise = makeCancelable(delayedPromise(durationMs));\n\n  // Kick off promise chain\n  bufferingPromise.promise\n    .then(() => instance.update(Action.BufferingEnded()))\n    .catch(\n      _reason => {}\n      //console.log({ isCanceled: _reason.isCanceled })\n    );\n\n  // Side-effect; set the promise in the cache\n  instance.promiseCache.buffering = bufferingPromise;\n};\n\n/** Get a command that sets an image loading Promise */\nconst getLoadingCmd = (\n  imageProps: ImageProps,\n  experimentalDecode?: boolean\n): Cmd => instance => {\n  // Make cancelable loading Promise\n  const loadingPromise = makeCancelable(\n    loadImage(imageProps, experimentalDecode)\n  );\n\n  // Kick off request for Image and attach listeners for response\n  loadingPromise.promise\n    .then(_res => instance.update(Action.LoadSuccess({})))\n    .catch(e => {\n      // If the Loading Promise was canceled, it means we have stopped\n      // loading due to unmount, rather than an error.\n      if (!e.isCanceled) {\n        // TODO: think more about the error here\n        instance.update(Action.LoadError({ msg: \"Failed to load\" }));\n      }\n    });\n\n  // Side-effect; set the promise in the cache\n  instance.promiseCache.loading = loadingPromise;\n};\n\n/** Command that cancels the buffering Promise */\nconst cancelBufferingCmd: Cmd = instance => {\n  // Side-effect; cancel the promise in the cache\n  // We know this exists if we are in a Buffering state\n  instance.promiseCache.buffering.cancel();\n};\n\n/**\n * Component that preloads the image once it is in the viewport,\n * and then swaps it in. Takes a render prop that allows to specify\n * what is rendered based on the loading state.\n */\nexport class LazyImageFull extends React.Component<\n  LazyImageFullProps,\n  LazyImageFullState\n> {\n  static displayName = \"LazyImageFull\";\n\n  /** A central place to store promises.\n   * A bit silly, but passing promsises directly in the state\n   * was giving me weird timing issues. This way we can keep\n   * the promises in check, and pick them up from the respective methods.\n   * FUTURE: Could pass the relevant key in Buffering and Loading, so\n   * that at least we know where they are from a single source.\n   */\n  promiseCache: {\n    [key: string]: CancelablePromise;\n  } = {};\n\n  initialState = LazyImageFullState.NotAsked();\n\n  /** Emit the next state based on actions.\n   *  This is the core of the component!\n   */\n  static reducer(\n    action: Action,\n    prevState: LazyImageFullState,\n    props: LazyImageFullProps\n  ): ReducerResult {\n    return Action.match(action, {\n      ViewChanged: ({ inView }) => {\n        if (inView === true) {\n          // If src is not specified, then there is nothing to preload; skip to Loaded state\n          if (!props.src) {\n            return { nextState: LazyImageFullState.LoadSuccess() }; // Error wtf\n          } else {\n            // If in view, only load something if NotAsked, otherwise leave untouched\n            return LazyImageFullState.match(prevState, {\n              NotAsked: () => {\n                // If debounce is specified, then start buffering\n                if (!!props.debounceDurationMs) {\n                  return {\n                    nextState: LazyImageFullState.Buffering(),\n                    cmd: getBufferingCmd(props.debounceDurationMs)\n                  };\n                } else {\n                  // If no debounce is specified, then start loading immediately\n                  return {\n                    nextState: LazyImageFullState.Loading(),\n                    cmd: getLoadingCmd(props, props.experimentalDecode)\n                  };\n                }\n              },\n              // Do nothing in other states\n              default: () => ({ nextState: prevState })\n            });\n          }\n        } else {\n          // If out of view, cancel if Buffering, otherwise leave untouched\n          return LazyImageFullState.match(prevState, {\n            Buffering: () => ({\n              nextState: LazyImageFullState.NotAsked(),\n              cmd: cancelBufferingCmd\n            }),\n            // Do nothing in other states\n            default: () => ({ nextState: prevState })\n          });\n        }\n      },\n      // Buffering has ended/succeeded, kick off request for image\n      BufferingEnded: () => ({\n        nextState: LazyImageFullState.Loading(),\n        cmd: getLoadingCmd(props, props.experimentalDecode)\n      }),\n      // Loading the image succeeded, simple\n      LoadSuccess: () => ({ nextState: LazyImageFullState.LoadSuccess() }),\n      // Loading the image failed, simple\n      LoadError: e => ({ nextState: LazyImageFullState.LoadError(e) })\n    });\n  }\n\n  constructor(props: LazyImageFullProps) {\n    super(props);\n    this.state = this.initialState;\n\n    // Bind methods\n    this.update = this.update.bind(this);\n  }\n\n  update(action: Action) {\n    // Get the next state and any effects\n    const { nextState, cmd } = LazyImageFull.reducer(\n      action,\n      this.state,\n      this.props\n    );\n\n    // Debugging\n    if (this.props.debugActions) {\n      if (process.env.NODE_ENV === \"production\") {\n        console.warn(\n          'You are running LazyImage with debugActions=\"true\" in production. This might have performance implications.'\n        );\n      }\n      console.log({ action, prevState: this.state, nextState });\n    }\n\n    // Actually set the state, and kick off any effects after that\n    this.setState(nextState, () => cmd && cmd(this));\n  }\n\n  componentWillUnmount() {\n    // Clear the Promise Cache\n    if (this.promiseCache.loading) {\n      // NOTE: This does not cancel the request, only the callback.\n      // We weould need fetch() and an AbortHandler for that.\n      this.promiseCache.loading.cancel();\n    }\n    if (this.promiseCache.buffering) {\n      this.promiseCache.buffering.cancel();\n    }\n    this.promiseCache = {};\n  }\n\n  // Render function\n  render() {\n    // This destructuring is silly\n    const {\n      children,\n      loadEagerly,\n      observerProps,\n      experimentalDecode,\n      debounceDurationMs,\n      debugActions,\n      ...imageProps\n    } = this.props;\n\n    if (loadEagerly) {\n      // If eager, skip the observer and view changing stuff; resolve the imageState as loaded.\n      return children({\n        // We know that the state tags and the enum match up\n        imageState: LazyImageFullState.LoadSuccess().tag as ImageState,\n        imageProps\n      });\n    } else {\n      return (\n        <Observer\n          rootMargin=\"50px 0px\"\n          // TODO: reconsider threshold\n          threshold={0.01}\n          {...observerProps}\n          onChange={inView => this.update(Action.ViewChanged({ inView }))}\n        >\n          {({ ref }) =>\n            children({\n              // We know that the state tags and the enum match up, apart\n              // from Buffering not being exposed\n              imageState:\n                this.state.tag === \"Buffering\"\n                  ? ImageState.Loading\n                  : (this.state.tag as ImageState),\n              imageProps,\n              ref\n            })\n          }\n        </Observer>\n      );\n    }\n  }\n}\n\n///// Utilities /////\n\n/** Promise constructor for loading an image */\nconst loadImage = (\n  { src, srcSet, alt, sizes }: ImageProps,\n  experimentalDecode = false\n) =>\n  new Promise((resolve, reject) => {\n    const image = new Image();\n    if (srcSet) {\n      image.srcset = srcSet;\n    }\n    if (alt) {\n      image.alt = alt;\n    }\n    if (sizes) {\n      image.sizes = sizes;\n    }\n    image.src = src;\n\n    /** @see: https://www.chromestatus.com/feature/5637156160667648 */\n    if (experimentalDecode && \"decode\" in image) {\n      return (\n        image\n          // NOTE: .decode() is not in the TS defs yet\n          // TODO: consider writing the .decode() definition and sending a PR\n          //@ts-ignore\n          .decode()\n          .then(() => resolve(image))\n          .catch((err: any) => reject(err))\n      );\n    }\n\n    image.onload = resolve;\n    image.onerror = reject;\n  });\n\n/** Promise that resolves after a specified number of ms */\nconst delayedPromise = (ms: number) =>\n  new Promise(resolve => setTimeout(resolve, ms));\n\ninterface CancelablePromise {\n  promise: Promise<{}>;\n  cancel: () => void;\n}\n\n/** Make a Promise \"cancelable\".\n *\n * Rejects with {isCanceled: true} if canceled.\n *\n * The way this works is by wrapping it with internal hasCanceled_ state\n * and checking it before resolving.\n */\nconst makeCancelable = (promise: Promise<any>): CancelablePromise => {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise<{}>((resolve, reject) => {\n    promise.then((val: any) =>\n      hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)\n    );\n    promise.catch((error: any) =>\n      hasCanceled_ ? reject({ isCanceled: true }) : reject(error)\n    );\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    }\n  };\n};\n","import React from \"react\";\nimport {\n  LazyImageFull,\n  CommonLazyImageProps,\n  ImageState,\n  ImageProps\n} from \"./LazyImageFull\";\n\n/**\n * Valid props for LazyImage\n */\nexport interface LazyImageRenderPropArgs {\n  imageProps: ImageProps;\n}\n\nexport interface RefArg {\n  /** When not loading eagerly, a ref to bind to the DOM element. This is needed for the intersection calculation to work. */\n  ref?: React.RefObject<any>;\n}\n\nexport interface LazyImageProps extends CommonLazyImageProps {\n  /** Component to display once image has loaded */\n  actual: (args: LazyImageRenderPropArgs) => React.ReactElement<{}>;\n\n  /** Component to display while image has not been requested\n   * @default: undefined\n   */\n  placeholder: (\n    args: LazyImageRenderPropArgs & RefArg\n  ) => React.ReactElement<{}>;\n\n  /** Component to display while the image is loading\n   * @default placeholder, if defined\n   */\n  loading?: () => React.ReactElement<{}>;\n\n  /** Component to display if the image fails to load\n   * @default actual (broken image)\n   */\n  error?: () => React.ReactElement<{}>;\n}\n\n/**\n * Component that preloads the image once it is in the viewport,\n * and then swaps it in. Has predefined rendering logic, but the\n * specifics are up to the caller.\n */\nexport const LazyImage: React.StatelessComponent<LazyImageProps> = ({\n  actual,\n  placeholder,\n  loading,\n  error,\n  ...rest\n}) => (\n  <LazyImageFull {...rest}>\n    {({ imageState, imageProps, ref }) => {\n      // Call the appropriate render callback based on the state\n      // and the props specified, passing on relevant props.\n      switch (imageState) {\n        case ImageState.NotAsked:\n          return !!placeholder && placeholder({ imageProps, ref });\n\n        case ImageState.Loading:\n          // Only render loading if specified, otherwise placeholder\n          return !!loading\n            ? loading()\n            : !!placeholder && placeholder({ imageProps, ref });\n\n        case ImageState.LoadSuccess:\n          return actual({ imageProps });\n\n        case ImageState.LoadError:\n          // Only render error if specified, otherwise actual (broken image)\n          return !!error ? error() : actual({ imageProps });\n      }\n    }}\n  </LazyImageFull>\n);\n\nLazyImage.displayName = \"LazyImage\";\n"],"names":["ImageState","_excluded","LazyImageFullState","unionize","NotAsked","Buffering","Loading","LoadSuccess","LoadError","ofType","ViewChanged","BufferingEnded","imageProps","experimentalDecode","instance","loadingPromise","makeCancelable","loadImage","promise","then","_res","update","Action","e","isCanceled","msg","promiseCache","loading","cancelBufferingCmd","buffering","cancel","LazyImageFull","_React$Component","props","_this","call","this","initialState","state","bind","_assertThisInitialized","reducer","action","prevState","match","inView","src","debounceDurationMs","nextState","cmd","durationMs","bufferingPromise","delayedPromise","_reason","getLoadingCmd","default","React","_this2","debugActions","process","env","NODE_ENV","console","warn","log","setState","componentWillUnmount","_proto","render","_this3","_this$props","children","loadEagerly","observerProps","_objectWithoutPropertiesLoose","imageState","tag","createElement","Observer","Object","assign","rootMargin","threshold","onChange","_ref2","ref","Component","displayName","_ref3","srcSet","alt","sizes","resolve","reject","image","Image","srcset","decode","err","onload","onerror","ms","Promise","setTimeout","val","hasCanceled_","error","actual","placeholder","_ref","rest","LazyImage"],"mappings":"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"}